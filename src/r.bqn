âŸ¨âŸ¨FmtâŸ©â‡strings, nsâŸ© â†â€¢Import "util.bqn"
dbâ†â€¢Import "db.bqn"
init_c  â† "../lib.so" â€¢FFI ""â€¿"init"
input_c â† "../lib.so" â€¢FFI "a"â€¿"input"

p â† âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # inspection points

Init_c âŸ¨âŸ©

Listâ†{ 
  ğ•© 
}

Help â† {ğ•© }

Queryâ†{ 
  ğ•Š: ğ•©
  #â€¢Show "query"â€¿ğ•©
}

Historyâ†{ ğ•Š:
  ğ•©
}

# Repl specific operations
optsâ†â‰[
  "?"â€¿Query

  "?h"â€¿Help
  "?help"â€¿Help

  "?l"â€¿List
  "?list"â€¿List
  #")r"â€¿R
  # TODO explain
]

systemâ†âŸ¨
  "show"â€¿â€¢Show, 
  "query"â€¿Query, "q"â€¿Query,
  "history"â€¿History, "h"â€¿History
âŸ©

replâ† â€¢ReBqn {replâ‡"loose"â‹„ systemâ‡system}

Eval â† { ğ•Š l:
  nâ†â‰ Â¨âŠopts â‹„ mâ†âˆ¾n{ğ•©â·ğ•¨â†‘l}Â¨âŠopts â‹„ {fâ†1âŠ‘ğ•©â‹„F l}Ë˜m/â‰opts # run opts eg. )l

  # get all variables after line in body
  # inject into repl
  # auto complete line fragements

  {ğ•Š:â€¢Show ReplâŠâ€¢CurrentError l}âŸ((0<â‰ l)âˆ§Â¬âˆ¨Â´m) @ # run repl
}

lâ†4

Setâ‡{ ğ•Š:
  
  replâ†©â€¢ReBqn {replâ‡"loose"â‹„ systemâ‡system}
  
  db.Exec â€¢SHow "
      select name, max(line) from refs 
        inner join calls on vals.call=calls.id 
        inner join vals on vals.ref = refs.id 
        inner join bodies 
        where   
            refs.line >= bodies.start_line  and 
            refs.line <= {}                 and 
            calls.id={}
        group by 
            refs.name
  " Fmt 4â€¿2
  #select DISTINCT * from refs 
      #inner join calls on vals.call=calls.id 
      #inner join vals on vals.ref = refs.id 
      #inner join bodies 
      #where refs.line <= bodies.end_line 
          #and refs.line = (SELECT MAX(line) from refs)
          #and refs.line >= bodies.start_line  
          #and calls.id=4;


  #âŸ¨"","",âŸ© Repl ""

}

Runâ‡{ 
  ğ•Š âŸ¨âŸ©: 
    { ğ•Š:
      lâ†Input_c âŸ¨âŸ© 
      â€¢Show l
      â€¢ExitâŸ(l=0) 0 # run cancel
      Eval l
    }â€¢_while_ 1 1 
; ğ•Š ğ•©: EvalÂ¨ğ•©
}

