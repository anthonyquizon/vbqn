âŸ¨âŸ¨FmtâŸ©â‡strings, nsâŸ© â†â€¢Import "util.bqn"
stateâ†â€¢Import "s.bqn"
init_c  â† "../lib.so" â€¢FFI ""â€¿"init"
input_c â† "../lib.so" â€¢FFI "a"â€¿"input"

p â† âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # inspection points

Init_c âŸ¨âŸ©

Listâ†{ 
  ğ•© 
}

Help â† {ğ•© }

Queryâ†{ 
  ğ•Š: ğ•©
  #â€¢Show "query"â€¿ğ•©
}

Historyâ†{ ğ•Š:
  ğ•©
}

# Repl specific operations
optsâ†â‰[
  "?"â€¿Query

  "?h"â€¿Help
  "?help"â€¿Help

  "?l"â€¿List
  "?list"â€¿List
  #")r"â€¿R
  # TODO explain
]

systemâ†âŸ¨
  "show"â€¿â€¢Show, 
  "query"â€¿Query, "q"â€¿Query,
  "history"â€¿History, "h"â€¿History
âŸ©

replâ† â€¢ReBqn {replâ‡"loose"â‹„ systemâ‡system}

Eval â† { ğ•Š l:
  nâ†â‰ Â¨âŠopts â‹„ mâ†âˆ¾n{ğ•©â·ğ•¨â†‘l}Â¨âŠopts â‹„ {fâ†1âŠ‘ğ•©â‹„F l}Ë˜m/â‰opts # run opts eg. )l

  # get all variables after line in body
  # inject into repl
  # auto complete line fragements

  {ğ•Š:â€¢Show ReplâŠâ€¢CurrentError l}âŸ((0<â‰ l)âˆ§Â¬âˆ¨Â´m) @ # run repl
}

#Setâ‡{ ğ•Š ğ•©:
  #replâ†©â€¢ReBqn {replâ‡"loose"}
  #nâ†state.Restore ğ•©
  #{ğ•Š:
    #lâ†Input_c âŸ¨âŸ© 
    #â€¢ExitâŸ(l=0) 0 # run cancel
    #varsâ†"âŸ¨{}âŸ©â†2â†“â€¢args" Fmt âŸ¨(1â†“âˆ¾','âŠ¸âˆ¾Â¨(2â†“âŠâ‰>n))âŸ©
    ## TODO drop in line
    #â€¢Show âŸ¨"","",1âŠâ‰>nâŸ© Repl "(1âŠ‘â€¢args) { ğ•¨ ğ•Š ğ•©: {} â‹„ {} } âŠ‘â€¢args" Fmt âŸ¨vars, lâŸ©
  #}â€¢_while_ 1 1 
#}

Runâ‡{ 
  ğ•Š âŸ¨âŸ©: 
    { ğ•Š:
      lâ†Input_c âŸ¨âŸ© 
      â€¢Show l
      â€¢ExitâŸ(l=0) 0 # run cancel
      Eval l
    }â€¢_while_ 1 1 #@a
; ğ•Š ğ•©: EvalÂ¨ğ•©
}

