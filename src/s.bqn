âŸ¨âŸ¨FmtâŸ©â‡stringsâŸ©â†â€¢Import "util.bqn"
lfâ†@+10

# variables to record
audit â‡ âŸ¨âŸ©

bodym â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
linm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # file -> bytcode to lines 
colm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # file -> bytcode to lines
refm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
valm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©

dataâ†âŸ¨âŸ©

MakeStack â† {
  s â† ğ•©                          # Stack (a list)
  Push â‡ {sâˆ¾â†©<ğ•© â‹„ ğ•©}                 # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                # Return but don't pop top value
}

# i32:c8 â†’ i32: the c data type that is converted to and c8: the bqn data type that is converted from
sqlâ‡{
  sqlite_init_c       â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_init"â€¿"*u8:c8"
  sqlite_exec_c       â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_exec"â€¿"*u32:c32"
  sqlite_close_c      â† "../lib.so" â€¢FFI ""â€¿"sqlite_close"
  sqlite_last_rowid_c â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_last_rowid"

  Init      â‡ { Sqlite_init_c âŸ¨ğ•©âˆ¾@+0âŸ©     }
  Exec      â‡ { Sqlite_exec_c âŸ¨ğ•©âˆ¾@+0âŸ©     }
  Close     â‡ { ğ•Š: Sqlite_close_c âŸ¨âŸ©      }
  LastRowId â‡ { ğ•Š: Sqlite_last_rowid_c âŸ¨âŸ© }

  Setup â‡ { ğ•Š:
    â€¢SH "rm"â€¿"-r"â€¿"_data/db" 
    Init "_data/db"
    Exec â€¢FChars "tables.sql"
  }
}

ctx â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Push â‡ {
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿âŠ‘ s.Peek @
    s.Push {cwdâ‡â€¢file.Parent f, srcâ‡â€¢file.Chars f, fileâ‡f}
  }

  Peek â‡ s.Peek
  Pop  â‡ s.Pop
}

# Rename?
SetFileLocâ‡{
  ğ•Š loc:
    âŸ¨src,fileâŸ©â†ctx.Peek @
    file colm.Set âˆ¾+`Â¨1Â¨Â¨âŠ”+`src=lf
    file linm.Set 1++`src=lf        # convert locs to line numbers
}

bodies â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Pushâ‡{ ğ•Š iâ€¿Â·:
    âŸ¨src,fileâŸ© â†ctx.Peek @
    kâ†iâˆ¾âŸ¨fileâŸ©

    Insertâ†{ ğ•Š:
      lineâ†iâŠ‘linm.Get file â‹„ colâ†iâŠ‘colm.Get file  
      id â†(bodym.Count @)
      k bodym.Set id
      sql.Exec "insert into bodies(id, file, line, col) values ({}, '{}', {}, {})" Fmt idâ€¿fileâ€¿lineâ€¿col
      id
    }

    idâ†(bodym.Has)â—¶Insertâ€¿bodym.Get k
    sql.Exec "insert into history(body) values ({})" Fmt id
    s.Push id
  }

  Popâ‡{ ğ•Š: (âŠ‘s.Pop 1) }
  Peekâ‡s.Peek
}

Refâ†{ bodyâ€¿name ğ•Š fileâ€¿i:
  Insertâ†{ ğ•Š:
    lineâ†iâŠ‘linm.Get file â‹„ colâ†iâŠ‘colm.Get file  
    sql.Exec "insert into refs(body, name, line, col) values ({}, '{}', {}, {})" Fmt bodyâ€¿nameâ€¿lineâ€¿col
    idâ†sql.LastRowId @
    bodyâ€¿name refm.Set id
    id
  }

  (refm.Has)â—¶Insertâ€¿refm.Get bodyâ€¿name
}

Hashâ†{
  ğ•©: 6=â€¢Type ğ•© ? â€¢Hash 0 # TODO implement
; ğ•©: â€¢Hash ğ•©
}

Recâ‡{ nameâ€¿âŸ¨i,Â·âŸ© ğ•Š v:
  âŸ¨fileâŸ©â†ctx.Peek @ â‹„ bodyâ†bodies.Peek @ 
  id â† bodyâ€¿name Ref fileâ€¿i

  Cacheâ†{ğ•Š: nâ†â‰ data â‹„ dataâ†©dataâˆ¾âŸ¨vâŸ© â‹„ (ğ•©âŠ¸valm.Set)âŠ¸âŠ¢n }
  nâ† (valm.Has)â—¶Cacheâ€¿valm.Get Hash v

  sql.Exec "insert into vals(ref, i, type) values ({}, {}, {})" Fmt idâ€¿nâ€¿(â€¢Type v)
}

