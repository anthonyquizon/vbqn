âŸ¨âŸ¨FmtâŸ©â‡strings, âŸ¨UpdateâŸ©â‡hashmapâŸ©â†â€¢Import "util.bqn"
lfâ†@+10

# variables to record
audit â‡ âŸ¨âŸ©

idm   â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
linm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # file -> bytcode to lines 
colm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # file -> bytcode to lines
datm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # data map

#do_regâ†1 # if registration phase has completed

#Start â‡ { ğ•Š: 1 }
#End   â‡ { ğ•Š: do_regâ†©0 }

MakeStack â† {
  s â† ğ•©                          # Stack (a list)
  Push â‡ {sâˆ¾â†©<ğ•© â‹„ ğ•©}                 # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                # Return but don't pop top value
}

# i32:c8 â†’ i32: the c data type that is converted to and c8: the bqn data type that is converted from
sqlâ‡{
  sqlite_init_c       â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_init"â€¿"*u8:c8"
  sqlite_exec_c       â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_exec"â€¿"*u32:c32"
  sqlite_close_c      â† "../lib.so" â€¢FFI ""â€¿"sqlite_close"
  sqlite_last_rowid_c â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_last_rowid"

  Init      â‡ { Sqlite_init_c âŸ¨ğ•©âˆ¾@+0âŸ©     }
  Exec      â‡ { Sqlite_exec_c âŸ¨ğ•©âˆ¾@+0âŸ©     }
  Close     â‡ { ğ•Š: Sqlite_close_c âŸ¨âŸ©      }
  LastRowId â‡ { ğ•Š: Sqlite_last_rowid_c âŸ¨âŸ© }

  Setup â‡ { ğ•Š:
    â€¢SH "rm"â€¿"-r"â€¿"_data/db" 
    Init "_data/db"
    Exec â€¢FChars "tables.sql"
  }
}

ctx â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Push â‡ {
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿âŠ‘ s.Peek @
    s.Push {cwdâ‡â€¢file.Parent f, srcâ‡â€¢file.Chars "../"âˆ¾f, fileâ‡f}
  }

  Peek â‡ s.Peek
  Pop  â‡ s.Pop
}

# Rename?
SetFileLocâ‡{
  ğ•Š loc:
    âŸ¨src,fileâŸ©â†ctx.Peek @
    file colm.Set âˆ¾+`Â¨1Â¨Â¨âŠ”+`src=lf
    file linm.Set 1++`src=lf        # convert locs to line numbers
}

bodies â‡ {
  s â‡ MakeStack âŸ¨âŸ©
  c â‡ 0

  Pushâ‡{
    startâ€¿Â·â†ğ•©
      âŸ¨src,fileâŸ© â†ctx.Peek @
      idâ†idmâ€¿(startâˆ¾âŸ¨fileâŸ©) Update (idm.Count @)
      c +âŸœ1â†©

      sql.Exec "insert or replace into bodies(id, start, file) values ({}, {}, '{}')" Fmt idâ€¿startâ€¿file
      sql.Exec "insert into history(body) values ({})" Fmt id
      s.Push id
  }

  Popâ‡{ ğ•Š: (âŠ‘s.Pop 1) }
  Peekâ‡s.Peek
}

Regâ†{ bodyâ€¿nameâ€¿fileâ€¿i:
  lâ†iâŠ‘linm.Get file â‹„ câ†iâŠ‘colm.Get file  
  sql.Exec "insert or replace into vars(body, name, line, col) values ({}, '{}', {}, {})" Fmt bodyâ€¿nameâ€¿lâ€¿c
  sql.LastRowId @
}


## TODO rec arr shape/min/max/function query value

Recâ‡{ nameâ€¿âŸ¨i,Â·âŸ© ğ•Š v:
  âŸ¨fileâŸ©â†ctx.Peek @ â‹„ bodyâ†bodies.Peek @ 
  idâ† Reg bodyâ€¿nameâ€¿fileâ€¿i
  id datm.Set v
}

