âŸ¨âŸ¨FmtâŸ©â‡stringsâŸ©â†â€¢Import "util.bqn"
lfâ†@+10

# variables to record
audit â‡ âŸ¨âŸ©

bodym â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
refm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
valm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
filem â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©

dataâ†âŸ¨âŸ©

MakeStack â† {
  s â‡ ğ•©                          # Stack (a list)
  Push â‡ {sâˆ¾â†©<ğ•© â‹„ ğ•©}                 # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                # Return but don't pop top value
}

# i32:c8 â†’ i32: the c data type that is converted to and c8: the bqn data type that is converted from
sqlâ‡{
  sqlite_init_c       â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_init"â€¿"*u8:c8"
  sqlite_exec_c       â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_exec"â€¿"*u32:c32"
  sqlite_close_c      â† "../lib.so" â€¢FFI ""â€¿"sqlite_close"
  sqlite_last_rowid_c â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_last_rowid"

  Init      â‡ { Sqlite_init_c âŸ¨ğ•©âˆ¾@+0âŸ©     }
  Exec      â‡ { Sqlite_exec_c âŸ¨ğ•©âˆ¾@+0âŸ©     }
  Close     â‡ { ğ•Š: Sqlite_close_c âŸ¨âŸ©      }
  LastRowId â‡ { ğ•Š: Sqlite_last_rowid_c âŸ¨âŸ© }

  Setup â‡ { ğ•Š:
    â€¢SH "rm"â€¿"-r"â€¿"_data/db" 
    Init "_data/db"
    Exec â€¢FChars "tables.sql"
  }
}


ctx â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Push â‡ { args ğ•Š ğ•©:
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿(â€¢ns.GetâŸœ"cwd") s.Peek @

    Cacheâ†{
      file  â‡ f
      args  â‡ args 
      src   â‡ â€¢file.Chars ğ•© 
      cols  â‡ âˆ¾+`Â¨1Â¨Â¨âŠ”+`src=lf
      lines â‡ 1++`src=lf 
    }
    (filem.SetâŸœCache)âŸ(Â¬âˆ˜filem.Has) f
    s.Push { cwdâ‡â€¢file.Parent f }
    filem.Get f
  }

  Peek â‡ s.Peek
  Pop  â‡ s.Pop
}

#trace â‡ {
  #s â‡ MakeStack âŸ¨âŸ©
  #fâ‡@

  #Set â‡ {
    #ğ•Š loc:
      #âŸ¨colâŸ©â†ctx.Peek @
      #fâ†©loc
  #}

  #Push â‡ { ğ•Š: s.Push f }
  #Pop  â‡ s.Pop
#}

bodies â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Pushâ‡{ file ğ•Š iâ€¿Â·:
    âŸ¨lines, colsâŸ©â†filem.Get file
    kâ†iâˆ¾âŸ¨fileâŸ©

    Insertâ†{ ğ•Š:
      lineâ†iâŠ‘lines â‹„ colâ†iâŠ‘cols
      id â†(bodym.Count @)
      k bodym.Set id
      sql.Exec "insert into bodies(id, file, line, col) values ({}, '{}', {}, {})" Fmt idâ€¿fileâ€¿lineâ€¿col
      id
    }

    idâ†(bodym.Has)â—¶Insertâ€¿bodym.Get k
    sql.Exec "insert into history(body, depth) values ({}, {})" Fmt idâ€¿(â‰ s.s)
    s.Push {idâ‡id â‹„ fileâ‡file}
  }

  Popâ‡{ ğ•Š: (âŠ‘s.Pop 1) }
  Peekâ‡s.Peek
}

Refâ†{ bodyâ€¿name ğ•Š fileâ€¿i:
  Insertâ†{ ğ•Š:
    âŸ¨cols,linesâŸ© â† filem.Get file
    lineâ†iâŠ‘lines â‹„ colâ†iâŠ‘cols
    sql.Exec "insert into refs(body, name, line, col) values ({}, '{}', {}, {})" Fmt bodyâ€¿nameâ€¿lineâ€¿col
    idâ†sql.LastRowId @
    bodyâ€¿name refm.Set id
    id
  }

  (refm.Has)â—¶Insertâ€¿refm.Get bodyâ€¿name
}

#Hashâ†{
  #ğ•©: 6=â€¢Type ğ•© ? â€¢Hash 0 # TODO implement
#; ğ•©: â€¢Hash ğ•©
#}

Hashâ†â€¢Hash

Recâ‡{ nameâ€¿âŸ¨i,Â·âŸ© ğ•Š v:
  âŸ¨id,fileâŸ©â†bodies.Peek @ 
  râ† idâ€¿name Ref fileâ€¿i

  Cacheâ†{ğ•Š: nâ†â‰ data â‹„ dataâ†©dataâˆ¾âŸ¨vâŸ© â‹„ (ğ•©âŠ¸valm.Set)âŠ¸âŠ¢n }
  nâ† (valm.Has)â—¶Cacheâ€¿valm.Get Hash v

  sql.Exec "insert into vals(ref, data_index, type) values ({}, {}, {})" Fmt râ€¿nâ€¿(â€¢Type v)
}

