âŸ¨âŸ¨FmtâŸ©â‡stringsâŸ©â†â€¢Import "util.bqn"
lfâ†@+10

# variables to record
audit â‡ âŸ¨âŸ©
dataâ†âŸ¨âŸ©
filemâ†âŸ¨âŸ©â€¢HashMapâŸ¨âŸ©
bodymâ†âŸ¨âŸ©â€¢HashMapâŸ¨âŸ©
refmâ†âŸ¨âŸ©â€¢HashMapâŸ¨âŸ©
valmâ†âŸ¨âŸ©â€¢HashMapâŸ¨âŸ©

dbâ†{
  iâ‡0
  sâ‡0â€¿3â¥ŠâŸ¨âŸ©
  Insertâ‡{ s (>FmtÂ¨ iâŠ¸âˆ¾Â¨((ğ•¨âˆ¾'/')âŠ¸âˆ¾)âŒ¾âŠ‘Â¨ğ•©)âŠ¸âˆ¾â†© â‹„ (i 1âŠ¸+â†©) âŠ¢ i } 
  MatchVar â†{ c ğ•Š vâ€¿t: (âˆ¨Â´)â—¶{ğ•Š:câˆ¾Ë˜[âŸ¨vâŸ©,âŸ¨tâŸ©]}â€¿{c MatchPart (âŠ‘ğ•©/1âŠc)â€¿t} âŸ¨vâŸ©â·âŠc }
  MatchPartâ†{
   @ ğ•Š Â·   : @
  ;c ğ•Š pâ€¿t: '?'=âŠ‘ p ? c MatchVar pâ€¿t                                                                  #@a
  ;c ğ•Š pâ€¿t: pâ‰¡t ? c
  ;Â· ğ•Š Â·  : @
  }
  MatchPatternâ†{ c ğ•Š pâ€¿t: c MatchPartËœÂ´ pâ‹ˆÂ¨t }
  QuerySingle â†{ c ğ•Š pâ€¿db: (âŠ£/Ëœ@âŠ¸â‰¢Â¨){ c MatchPattern pâ€¿ğ•© }Â¨<Ë˜db }
  QueryWhere â†{ ğ•Š pâ€¿db: âŸ¨[âŸ¨âŸ©,âŸ¨âŸ©]âŸ© {âˆ¾(QuerySingleâŸœ(ğ•¨â€¿db))Â¨ğ•©}Â´p }
  Actualizeâ†{ câ†ğ•¨ â‹„ mâ†('?'=âŠ‘)Â¨ğ•© â‹„ {(1âŠc)âŠËœğ•©âŠËœâŠc}âŒ¾(mâŠ¸/) ğ•© }
  Queryâ†{ 
    db ğ•Š âŸ¨f,wâŸ©: db ğ•Š âŸ¨f,w,âŸ¨âŸ©âŸ©
  ; db ğ•Š fâ€¿wâ€¿l: 
    râ†ActualizeâŸœfÂ¨dbâŠ¸QueryWhere w 
    r/Ëœâˆ§Â´(1âŠ‘Â¨l) {âˆ¨Â´Â¨(ğ•¨)âŠ¸â·Â¨ğ•©âŠ¸âŠ‘Â¨r}Â¨{ âŠ‘/(âŠ‘ğ•©)âŠ¸â‰¡Â¨f}Â¨l  # filter 'like' query
  }
}

MakeStack â† {
  s â‡ ğ•©                                                                                               # Stack (a list)
  Push â‡ {sâˆ¾â†©<ğ•© â‹„ ğ•©}                                                                                  # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s}                                                                      # Pop ğ•© values; return as list
  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                                                                          # Return but don't pop top value
}

ctx â‡ {
  s â‡ MakeStack âŸ¨âŸ©
  Push â‡ { args ğ•Š ğ•©:
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿(â€¢ns.GetâŸœ"cwd") s.Peek @ 
    Cacheâ†{
      


      file  â‡ f
      args  â‡ args 
      src   â‡ â€¢file.Chars ğ•© 
      cols  â‡ âˆ¾+`Â¨1Â¨Â¨âŠ”+`src=lf
      lines â‡ 1++`src=lf 
    }
    (filem.SetâŸœCache)âŸ(Â¬âˆ˜filem.Has) f
    s.Push { cwdâ‡â€¢file.Parent f }
    filem.Get f
  }
  Peek â‡ s.Peek
  Pop  â‡ s.Pop
}

bodies â‡ {
  s â‡ MakeStack âŸ¨âŸ©
  Pushâ‡{ file ğ•Š iâ€¿Â·:
    kâ†iâˆ¾âŸ¨fileâŸ©
    Insertâ†{ ğ•Š:
      id â†(bodym.Count @)
      k bodym.Set id
      "body" db.Insert âŸ¨"id"â€¿id, "file"â€¿fileâŸ©
      id
    }

    idâ†(bodym.Has)â—¶Insertâ€¿bodym.Get k
    callâ† "call" db.Insert âŸ¨"body"â€¿id, "depth"â€¿(â‰ s.s)âŸ©
    s.Push {idâ‡id â‹„ fileâ‡file â‹„ callâ‡call}
  }

  Popâ‡{ file ğ•Š startâ€¿end: 
    âŸ¨lines, colsâŸ©â†filem.Get file
    start_lineâ†startâŠ‘lines â‹„ end_lineâ†endâŠ‘lines
    start_colâ†startâŠ‘cols â‹„ end_colâ†endâŠ‘cols
    âŸ¨idâŸ©â†(âŠ‘s.Pop 1) 
    #"body" db.Insert âŸ¨"bodies/start"â€¿""âŸ©
    #db.Exec "update bodies set start_line={}, end_line={}, start_col={}, end_col={} where id={}" Fmt start_lineâ€¿end_lineâ€¿start_colâ€¿end_colâ€¿id
  }
  Peekâ‡s.Peek
}

Refâ†{ bodyâ€¿name ğ•Š fileâ€¿i:
  âŸ¨cols,linesâŸ© â† filem.Get file
  lineâ†iâŠ‘lines â‹„ colâ†iâŠ‘cols
  kâ†bodyâ€¿nameâ€¿lineâ€¿col
  Insertâ†{ ğ•Š:
    #db.Exec "insert into refs(body, name, line, col) values ({}, '{}', {}, {})" Fmt bodyâ€¿nameâ€¿lineâ€¿col
    idâ†db.LastRowId @
    k refm.Set id
    id
  }

  (refm.Has)â—¶Insertâ€¿refm.Get k
}

val â‡ {
  Recâ‡{ nameâ€¿âŸ¨i,Â·âŸ© ğ•Š v:
    âŸ¨id,file,callâŸ©â†bodies.Peek @ 
    râ† idâ€¿name Ref fileâ€¿i

    Cacheâ†{ğ•Š: nâ†â‰ data â‹„ dataâ†©dataâˆ¾âŸ¨vâŸ© â‹„ (ğ•©âŠ¸valm.Set)âŠ¸âŠ¢n }
    nâ† (valm.Has)â—¶Cacheâ€¿valm.Get â€¢Hash v

    #db.Exec "insert into vals(ref, data_index, call, type) values ({}, {}, {}, {})" Fmt râ€¿nâ€¿callâ€¿(â€¢Type v)
    #@a
  }
}

# TODO post processing
# unique bodies
