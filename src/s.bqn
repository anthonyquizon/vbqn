âŸ¨âŸ¨FmtâŸ©â‡stringsâŸ©â†â€¢Import "util.bqn"

varm    â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # variables and arguments
regm    â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # 
valm    â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # 
idm     â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
outm    â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
linem   â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
bodiesm â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
linesm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # file -> bytcode to lines 
colsm   â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© # file -> bytcode to lines 
history â‡ âŸ¨âŸ©

lfâ†@+10

# TODO function names
# TODO variable names from ids

MakeStack â† {
  s â† ğ•©                          # Stack (a list)
  Push â‡ {sâˆ¾â†©<ğ•© â‹„ ğ•©}                 # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                # Return but don't pop top value
}

ctx â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Push â‡ {
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿âŠ‘ s.Peek @
    srcâ†â€¢file.Chars "../"âˆ¾f
    s.Push âŸ¨â€¢file.Parent f, src, fâŸ©
  }

  Peek â‡ s.Peek
  Pop  â‡ s.Pop
}

Update â† { mâ€¿k ğ•Š f: m.Hasâ—¶{vâ†F @ â‹„ğ•© m.Set v â‹„ v}â€¿m.Get k }

# Rename?
SetFileLocâ‡{
  ğ•Š loc:
    âŸ¨Â·,src,fileâŸ© â†ctx.Peek @
    file colsm.Set âˆ¾+`Â¨1Â¨Â¨âŠ”+`src=lf
    file linesm.Set 1++`src=lf # convert locs to line numbers
}

# Hash: startâ€¿filenameâ€¿c
bodies â‡ {
  sâ‡ MakeStack âŸ¨âŸ©

  Pushâ‡{
    startâ€¿argsâ†ğ•©
      âŸ¨Â·,src,fileâŸ© â†ctx.Peek @
      idâ†idmâ€¿(startâˆ¾âŸ¨fileâŸ©) Update (idm.Count @)
      history âˆ¾âŸœ(âŸ¨idâŸ©)â†©
      s.Push id
  }

  Popâ‡{ (âŠ‘s.Pop 1) outm.Set ğ•© }

  Recâ‡{
    l ğ•Š v: 
      id â†s.Peek @ â‹„ iâ†1-Ëœâ‰ history
      (iâ€¿idâ€¿l) varm.Set v
  }

  # register variable location
  Regâ‡{
    name ğ•Š l:
      â€¢SHow nameâ€¿l
      âŸ¨Â·,Â·,fileâŸ© â†ctx.Peek @ 
      id â†s.Peek @
      lnâ†(âŠ‘l)âŠ‘linesm.Get file # lines
      csâ†lâŠcolsm.Get file     # columns
      (idâ€¿name) regm.Set csâˆ¾ln
  }
}


# i32:c8 â†’ i32: the c data type that is converted to and c8: the bqn data type that is converted from
sqlâ‡{
  sqlite_init_c  â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_init"â€¿"*u8:c8"
  sqlite_exec_c  â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_exec"â€¿"*u32:c32"
  sqlite_close_c â† "../lib.so" â€¢FFI ""â€¿"sqlite_close"

  Init  â‡ { Sqlite_init_c âŸ¨ğ•©âˆ¾@+0âŸ© }
  Exec  â‡ { Sqlite_exec_c âŸ¨ğ•©âˆ¾@+0âŸ© }
  Close â‡ { ğ•Š: Sqlite_close_c âŸ¨âŸ© }
  Populate â‡ { ğ•Š:
    #"v"â€¿"out"â€¿"idm"{â€¢Show ğ•¨ â‹„ â€¢Show >(ğ•©.Keys @)â€¿(ğ•©.Values @)}Â¨varmâ€¿outmâ€¿idm

    â€¢SH "rm"â€¿"-r"â€¿"_data/db"

    sql.Init "_data/db"
    sql.Exec â€¢FChars "tables.sql"

    # insert body info
    (idm.Keys@) {
      startâ€¿filename ğ•Š id:
        sql.Exec "insert into bodies(id, start, filename) values ({}, {}, '{}')" Fmt idâ€¿startâ€¿filename
    }Â¨idm.Values @

    # insert variables
    # TODO insert indices
    #(varm.Keys @){ 
      #callâ€¿idâ€¿name ğ•Š val:
        #sql.Exec "insert into vars(body, call, name, value, reified) values ({}, {}, '{}', '{}', true)" Fmt idâ€¿callâ€¿nameâ€¿(â€¢Fmt val)
    #} Â¨â€¢FmtÂ¨varm.Values @

    (regm.Keys @){ 
      idâ€¿name ğ•Š col_sâ€¿col_eâ€¿line:
        sql.Exec "insert into regs(body, name, col_s, col_e, line) values ({}, '{}', {}, {}, {})" Fmt idâ€¿nameâ€¿col_sâ€¿col_eâ€¿line
    } Â¨regm.Values @

    # insert history
    { sql.Exec "insert into history(body) values ({})" Fmt âŸ¨ğ•©âŸ© } Â¨history
  }
}

