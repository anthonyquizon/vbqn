âŸ¨âŸ¨FmtâŸ©â‡stringsâŸ©â†â€¢Import "util.bqn"
lfâ†@+10

# variables to record
audit â‡ âŸ¨âŸ©

bodym â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
refm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
valm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
filem â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©

dataâ†âŸ¨âŸ©

dbâ‡{
  sqlite_init_c       â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_init"â€¿"*u8:c8"
  sqlite_exec_c       â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_exec"â€¿"*u32:c32"â€¿"a"
  sqlite_close_c      â† "../lib.so" â€¢FFI ""â€¿"sqlite_close"
  sqlite_last_rowid_c â† "../lib.so" â€¢FFI "u64"â€¿"sqlite_last_rowid"

  Init      â‡ { Sqlite_init_c âŸ¨ğ•©âˆ¾@+0âŸ©     }
  Close     â‡ { ğ•Š: Sqlite_close_c âŸ¨âŸ©      }
  LastRowId â‡ { ğ•Š: Sqlite_last_rowid_c âŸ¨âŸ© }

  _Query â‡ { Sqlite_exec_c âŸ¨ğ•©âˆ¾@+0, ğ•—âŸ©   }
  Execâ‡{ dâ†âŸ¨âŸ© â‹„Sqlite_exec_c âŸ¨ğ•©âˆ¾@+0, {dâ†©dâˆ¾âŸ¨ğ•©âŸ©}âŸ© â‹„ d }

  Reset â‡ { ğ•Š:
    â€¢SH "rm"â€¿"-r"â€¿"_data/db" 
  }
  Setup â‡ { ğ•Š:
    Init "_data/db"

    sqlâ†â€¢FChars "tables.sql"
    sqlâ†©((âˆ¨`âˆ§âˆ¨âŸœÂ«)' 'âŠ¸â‰ )âŠ¸/sql 
    sqlâ†©';'((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)sql
    ExecÂ¨Â¯1â†“sql
  }
}

MakeStack â† {
  s â‡ ğ•©                          # Stack (a list)
  Push â‡ {sâˆ¾â†©<ğ•© â‹„ ğ•©}                 # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                # Return but don't pop top value
}


ctx â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Push â‡ { args ğ•Š ğ•©:
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿(â€¢ns.GetâŸœ"cwd") s.Peek @

    Cacheâ†{
      file  â‡ f
      args  â‡ args 
      src   â‡ â€¢file.Chars ğ•© 
      cols  â‡ âˆ¾+`Â¨1Â¨Â¨âŠ”+`src=lf
      lines â‡ 1++`src=lf 
    }
    (filem.SetâŸœCache)âŸ(Â¬âˆ˜filem.Has) f
    s.Push { cwdâ‡â€¢file.Parent f }
    filem.Get f
  }

  Peek â‡ s.Peek
  Pop  â‡ s.Pop
}

bodies â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Pushâ‡{ file ğ•Š iâ€¿Â·:
    kâ†iâˆ¾âŸ¨fileâŸ©

    Insertâ†{ ğ•Š:
      id â†(bodym.Count @)
      k bodym.Set id
      db.Exec "insert into bodies(id, file) values ({}, '{}')" Fmt idâ€¿file
      id
    }

    idâ†(bodym.Has)â—¶Insertâ€¿bodym.Get k
    db.Exec "insert into calls(body, depth) values ({}, {})" Fmt idâ€¿(â‰ s.s)
    callâ†db.LastRowId @
    s.Push {idâ‡id â‹„ fileâ‡file â‹„ callâ‡call}
  }

  Popâ‡{ file ğ•Š startâ€¿end: 
    âŸ¨lines, colsâŸ©â†filem.Get file
    start_lineâ†startâŠ‘lines â‹„ end_lineâ†endâŠ‘lines
    start_colâ†startâŠ‘cols â‹„ end_colâ†endâŠ‘cols
    âŸ¨idâŸ©â†(âŠ‘s.Pop 1) 
    db.Exec "update bodies set start_line={}, end_line={}, start_col={}, end_col={} where id={}" Fmt start_lineâ€¿end_lineâ€¿start_colâ€¿end_colâ€¿id
  }
  Peekâ‡s.Peek
}

Refâ†{ bodyâ€¿name ğ•Š fileâ€¿i:
  âŸ¨cols,linesâŸ© â† filem.Get file
  lineâ†iâŠ‘lines â‹„ colâ†iâŠ‘cols
  kâ†bodyâ€¿nameâ€¿lineâ€¿col
  Insertâ†{ ğ•Š:
    db.Exec "insert into refs(body, name, line, col) values ({}, '{}', {}, {})" Fmt bodyâ€¿nameâ€¿lineâ€¿col
    idâ†db.LastRowId @
    k refm.Set id
    id
  }

  (refm.Has)â—¶Insertâ€¿refm.Get k
}

val â‡ {
  Recâ‡{ nameâ€¿âŸ¨i,Â·âŸ© ğ•Š v:
    âŸ¨id,file,callâŸ©â†bodies.Peek @ 
    râ† idâ€¿name Ref fileâ€¿i

    Cacheâ†{ğ•Š: nâ†â‰ data â‹„ dataâ†©dataâˆ¾âŸ¨vâŸ© â‹„ (ğ•©âŠ¸valm.Set)âŠ¸âŠ¢n }
    nâ† (valm.Has)â—¶Cacheâ€¿valm.Get â€¢Hash v

    db.Exec "insert into vals(ref, data_index, call, type) values ({}, {}, {}, {})" Fmt râ€¿nâ€¿callâ€¿(â€¢Type v)
  }
}

Restoreâ‡{
  dâ†db.Exec "
    select name, vals.data_index from refs 
        inner join calls on vals.call=calls.id 
        inner join vals on vals.ref = refs.id 
        inner join bodies 
        where   
            refs.line >= bodies.start_line  and 
            refs.line <= {}                 and 
            calls.id={}
        group by 
            refs.name
  " Fmt ğ•©

  # sort ğ•© and ğ•¨ to be 0 and 1 indices
  â€¢Show d
  nâ†âŠâ‰>d
  xâ†2Ã—Â¬âˆ¨Â´Â¨"ğ•©"âŠ¸â·Â¨n
  mâ†â‹xâˆ¨Â´Â¨"ğ•¨"âŠ¸â·Â¨n
  {nâ€¿i: âŸ¨n,iâŠ‘dataâŸ©}Â¨mâŠd
}

