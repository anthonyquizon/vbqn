dbâ†â€¢Import "db.bqn"
âŸ¨âŸ¨FmtâŸ©â‡stringsâŸ©â†â€¢Import "util.bqn"
lfâ†@+10

# variables to record
audit â‡ âŸ¨âŸ©

bodym â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
refm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
valm  â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
filem â‡ âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©

dataâ†âŸ¨âŸ©

MakeStack â† {
  s â‡ ğ•©                          # Stack (a list)
  Push â‡ {sâˆ¾â†©<ğ•© â‹„ ğ•©}                 # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                # Return but don't pop top value
}


ctx â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Push â‡ { args ğ•Š ğ•©:
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿(â€¢ns.GetâŸœ"cwd") s.Peek @

    Cacheâ†{
      file  â‡ f
      args  â‡ args 
      src   â‡ â€¢file.Chars ğ•© 
      cols  â‡ âˆ¾+`Â¨1Â¨Â¨âŠ”+`src=lf
      lines â‡ 1++`src=lf 
    }
    (filem.SetâŸœCache)âŸ(Â¬âˆ˜filem.Has) f
    s.Push { cwdâ‡â€¢file.Parent f }
    filem.Get f
  }

  Peek â‡ s.Peek
  Pop  â‡ s.Pop
}

#trace â‡ {
  #s â‡ MakeStack âŸ¨âŸ©
  #fâ‡@

  #Set â‡ {
    #ğ•Š loc:
      #âŸ¨colâŸ©â†ctx.Peek @
      #fâ†©loc
  #}

  #Push â‡ { ğ•Š: s.Push f }
  #Pop  â‡ s.Pop
#}

bodies â‡ {
  s â‡ MakeStack âŸ¨âŸ©

  Pushâ‡{ file ğ•Š iâ€¿Â·:
    kâ†iâˆ¾âŸ¨fileâŸ©

    Insertâ†{ ğ•Š:
      id â†(bodym.Count @)
      k bodym.Set id
      db.Exec "insert into bodies(id, file) values ({}, '{}')" Fmt idâ€¿file
      id
    }

    idâ†(bodym.Has)â—¶Insertâ€¿bodym.Get k
    db.Exec "insert into calls(body, depth) values ({}, {})" Fmt idâ€¿(â‰ s.s)
    callâ†db.LastRowId @
    s.Push {idâ‡id â‹„ fileâ‡file â‹„ callâ‡call}
  }

  Popâ‡{ file ğ•Š startâ€¿end: 
    âŸ¨lines, colsâŸ©â†filem.Get file
    start_lineâ†startâŠ‘lines â‹„ end_lineâ†endâŠ‘lines
    start_colâ†startâŠ‘cols â‹„ end_colâ†endâŠ‘cols
    âŸ¨idâŸ©â†(âŠ‘s.Pop 1) 
    db.Exec â€¢Show "update bodies set start_line={}, end_line={}, start_col={}, end_col={} where id={}" Fmt start_lineâ€¿end_lineâ€¿start_colâ€¿end_colâ€¿id
  }
  Peekâ‡s.Peek
}

Refâ†{ bodyâ€¿name ğ•Š fileâ€¿i:
  âŸ¨cols,linesâŸ© â† filem.Get file
  lineâ†iâŠ‘lines â‹„ colâ†iâŠ‘cols
  kâ†bodyâ€¿nameâ€¿lineâ€¿col
  Insertâ†{ ğ•Š:
    db.Exec "insert into refs(body, name, line, col) values ({}, '{}', {}, {})" Fmt bodyâ€¿nameâ€¿lineâ€¿col
    idâ†db.LastRowId @
    k refm.Set id
    id
  }

  (refm.Has)â—¶Insertâ€¿refm.Get k
}

Hashâ†â€¢Hash

val â‡ {
  Recâ‡{ nameâ€¿âŸ¨i,Â·âŸ© ğ•Š v:
    âŸ¨id,file,callâŸ©â†bodies.Peek @ 
    râ† idâ€¿name Ref fileâ€¿i

    Cacheâ†{ğ•Š: nâ†â‰ data â‹„ dataâ†©dataâˆ¾âŸ¨vâŸ© â‹„ (ğ•©âŠ¸valm.Set)âŠ¸âŠ¢n }
    nâ† (valm.Has)â—¶Cacheâ€¿valm.Get Hash v

    db.Exec "insert into vals(ref, data_index, call, type) values ({}, {}, {}, {})" Fmt râ€¿nâ€¿callâ€¿(â€¢Type v)
  }
}

sysâ‡{
  Recâ‡{ ğ•Š: 
    # TODO
    ğ•©
  }
}

Restoreâ‡{
  accâ†âŸ¨âŸ©

  { accâ†©accâˆ¾âŸ¨ğ•©âŸ© â‹„ 0 } db._Query "
      select name, vals.data_index from refs 
        inner join calls on vals.call=calls.id 
        inner join vals on vals.ref = refs.id 
        inner join bodies 
        where   
            refs.line >= bodies.start_line  and 
            refs.line <= {}                 and 
            calls.id={}
        group by 
            refs.name
  " Fmt ğ•©

  {Â·â€¿i: â€¢SHow i}Â¨acc
  {Â·â€¿i: iâŠ‘data}Â¨acc
}
