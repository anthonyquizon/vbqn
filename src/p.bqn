gl      â†    â€¢Import "./glyphs.bqn"
compile â† gl â€¢Import "./c.bqn"
vm      â†    â€¢Import "./vm.bqn"

ansiâ†{
  eâ‡@+27
  bold_cyanâ‡eâˆ¾"[1;36m"
  red      â‡eâˆ¾"[31m"
  magenta  â‡eâˆ¾"[35m"
  bold_red â‡eâˆ¾"[1;31m"
  reset    â‡eâˆ¾"[0m"
}

lfâ†@+10
fmâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© #cached file information
imâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© #cached imported files
pmâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© #cached queries match to filenames

Infoâ†{ 
  f â‡ ğ•©âˆ¾".bqn"â‹„("Missing file "âˆ¾f)!â€¢file.Exists f # filename
  s â‡ â€¢file.Chars f                 # source files in chars
  l â‡ (lfâŠ¸â‰ )âŠ¸/Â¨sâŠ”ËœÂ»+`lf=s           # source file in lines
  n â‡ +`s=lf                        # line numbers
  c â‡ âˆ¾(â†•â‰ )Â¨âŠ”Ëœ+`s=@+10              # column numbers
  m â‡ â‰ /ËœâŒ½0<+`âŒ½Â¬(0âŠ¸=â‰ Â¨l)âˆ¨âˆ§Â´Â¨' 'âŠ¸=Â¨l # maximum line number
}

ctx â‡ {
  s â‡ âŸ¨âŸ©
  Push â‡ { ğ•Š ğ•©:
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿âŠ£ Peek @
    fâ†©f/ËœÂ¬+`(â‰ â†‘".bqn"âŠ¸â·)f # normalize: remove .bqn
    {ğ•© fm.Set Info ğ•©}âŸ(Â¬âˆ˜fm.Has) f
    sâˆ¾â†©<f
    fm.Get f
  }

  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                 # Return but don't pop top value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s}             # Pop ğ•© values; return as list
}

# Debug stack: keep track of calls
dbg â† {
  s â† âŸ¨âŸ©                          
  Push  â‡ { ğ•Š posâ€¿loc: # pos: index position of bytecode, loc: start/end position of call
    iâ†fm.Get ctx.Peek @
    oâ†|-Â´(pos-1)âŠ‘Â¨loc       # offset
    câ†i.câŠ‘Ëœ1-ËœâŠ‘(pos-1)âŠ‘Â¨loc # column
    lâ†i.nâŠ‘ËœposâŠ‘âŠ‘loc         # line
    fâ†i.f                   # file
    sâˆ¾â†©<oâ€¿câ€¿lâ€¿f 
  } 
  Pop   â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Print â‡ { ğ•Š: 
    â€¢Out âˆ¾âŸ¨ansi.bold_red,"Error: ", â€¢CurrentError@,ansi.resetâŸ©
    {ğ•Š oâ€¿câ€¿lâ€¿f : 
      iâ†fm.Get f
      â€¢Out âˆ¾âŸ¨ansi.red, f/ËœÂ¬(1Â¨â†•1-Ëœâ‰ p)âˆ¾(pâ†â€¢wdpathâˆ¾'/')â·f,':',â€¢Fmt l, ansi.resetâŸ©
      â€¢Out âˆ¾âŸ¨"  ",(l-1)âŠ‘i.lâŸ©
      â€¢Out âˆ¾âŸ¨ansi.red, "  ",(' 'Â¨â†•c), 'âˆ§'Â¨â†•o+1, ansi.resetâŸ©
    }Â¨âŒ½s
  }
}

sysfileâ‡{
  Linesâ‡{ 
    ğ•© : "/"â‰¤â—‹â‰ â—¶0â€¿(âŠ£â‰¡â‰ âŠ¸â†‘)ğ•© ? â€¢file.Lines ğ•© 
  ; ğ•© : â€¢file.Lines âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ â‹„ 
  } 
  List â‡{ â€¢file.List âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ } 
}

syslistâ†âŸ¨
    "p"â€¿â€¢Show # TODO show file and line number
    "while"â€¿â€¢_while_
    "hash"â€¿â€¢Hash
    "parsefloat"â€¿â€¢ParseFloat
    "ffi"â€¿â€¢FFI
    "out"â€¿â€¢Out
    "exit"â€¿â€¢Exit
    "file"â€¿sysfile
    "flines"â€¿sysfile.Lines
    "math"â€¿â€¢math
    "ns"  â€¿â€¢ns
    "show"â€¿â€¢Show
    "bqn"â€¿â€¢Bqn
    "repr"â€¿â€¢Repr
    "type"â€¿â€¢Type
âŸ©

System â†{ ğ•Š args:
  FindSys â† {
    i â† ğ•¨âŠğ•©
    { ! âˆ¾âŸ¨"Unknown system value",(1â‰ â‰ ğ•©)/"s",":"âŸ©âˆ¾" â€¢"âŠ¸âˆ¾Â¨ğ•© }âˆ˜/âŸœğ•©âŸ(âˆ¨Â´) i=â‰ ğ•¨
    i
  }

  { ğ•¨âŠ¸FindSysâŠğ•©Ë™ }Â´âˆ¾<Ë˜â‹ˆË˜â‰>syslistâˆ¾âŸ¨ "import"â€¿Import, "args"â€¿ğ•© âŸ©
}

CmpCatchâ†{ ğ•Š src:
  inâ†ctx.Peek@
  âŸ¨loc,msgâŸ©â†â€¢CurrentError@
  sâ€¿eâ†locâ†©â¥Šloc # convert to âŸ¨s,eâŸ©
  mâ†âˆ¨Â´in.nâŠ¸=Â¨locâŠin.n # 
  â€¢Out "Error: "âˆ¾msg
  â€¢Out in.fâˆ¾":"âˆ¾ â€¢Fmt sâŠ‘in.n
  â€¢Out (sâŠ‘in.n)âŠ‘in.l
  â€¢Out âŠ£â—¶" âˆ§"Â¨Â«(m/â†•â‰ src)âˆŠ(s+â†•1+e-s)
  â€¢Exit 1
}

MakeInspâ†{ğ•Š:
  fâ†ctx.Peek @ â‹„ inâ†fm.Get f â‹„ qâ†pm.Hasâ—¶âŸ¨âŸ©â€¿pm.Get f
  iâ†@ â‹„ lsâ†@

  â€¢Show pm.Values@
  â€¢Show pm.Keys@
  Preâ‡{posâ€¿loc:lsâ†©in.nâŠ‘ËœposâŠ‘âŠ‘loc}
  #Condâ†{ câ‰¡1 ? 1 ; nâ†©n+1 â‹„ 1â‰¡ ğ•©â€¿âŸ¨"n"â€¿nâŸ© Bqn c }
  Runâ‡{ 
    # TODO type
    Â· ğ•Š Â·: 0â‰¡â‰ q? @
  ; h ğ•Š posâ€¿loc: 
      lâ†in.nâŠ‘Ëœ(pos-1)âŠ‘âŠ‘loc â‹„ kâ†h.Keys@ â‹„ vâ†h.Values@
      bqnâ†â€¢ReBQN {systemâ‡âŸ¨"args"â€¿v, "i"â€¿i, "l"â€¿lâŸ©}
      Evalâ†{Bqn âˆ¾âŸ¨"âŸ¨",1â†“âˆ¾','âŠ¸âˆ¾Â¨k,"âŸ©â†â€¢args",lf,ğ•©âŸ©}

      #â€¢Show mâ†{Â·â€¿s: Eval s}Â¨q
      #{ğ•Š:(EnvVars env)âŠ¸{ğ•¨ ğ•©.Run lst+1}Â¨info.query}âŸ(1âŠ¸â‰¡) (lstâ‰ ln) 

      #ln â† Line@
      #lstâ†©ln
  }
}

Runâ‡Import â‡ {
    ğ•Š ğ•© : âŸ¨âŸ© ğ•Š ğ•©
; Â· ğ•Š ğ•© : im.Has ğ•© ? im.Get ğ•©
; args ğ•Š ğ•© : 
    inâ†ctx.Push ğ•©
    inspâ†MakeInsp @

    c â† (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System args, âŸ¨âŸ©âŸ©âŠ¸Compile)âŠCmpCatch in.s
    r â† inspâ€¿dbg VM c
    ğ•© im.Set r
    ctx.Pop 1 
    r
}

# f: file to query
# b: breakpoint to run query code
# c: conditional code to run to decide if src will be run
#MakeQuery0â‡{ fâ€¿bâ€¿c ğ•Š pâ€¿src: 
  #{(â€¢wdpathâˆ¾'/'âˆ¾ğ•©âˆ¾".bqn") fm.Set Info â€¢wdpathâˆ¾'/'âˆ¾ğ•©âˆ¾".bqn"}âŸ(Â¬âˆ˜fm.Has)Â¨f
  #infoâ†fm.Get â€¢wdpathâˆ¾'/'âˆ¾fâˆ¾".bqn"
  #â€¢Show bâ†©info.maxâŒŠb
  #nâ†0
  #Condâ†{ câ‰¡1 ? 1 ; nâ†©n+1 â‹„ 1â‰¡ ğ•©â€¿âŸ¨"n"â€¿nâŸ© Bqn c }
  #Runâ‡{ 
    ##h ğ•Š ln: (â€¢Show bâ‰¡ln)â—¶0â€¿Cond h ? 
    #h ğ•Š ln: (bâ‰¡â€¢Show ln) ? 
      #â€¢Out ansi.bold_cyanâˆ¾pâˆ¾ansi.reset
      #â€¢Show hâ€¿âŸ¨âŸ© Bqn src
  #; @
  #} 
#}

usageâ†âˆ¾âˆ¾âŸœlfÂ¨âŸ¨
  "Usage: pbqn [options] [file.bqn [arguments]]"
  "Options:"
  "  -p file   query file"
âŸ©

# === Main ===
{
  {ğ•Š:â€¢Out usageâ‹„â€¢Exit 0}âŸ(0âŠ¸=)â‰ â€¢args 

  # parse PBQN files
  pâ†â€¢wdpathâˆ¾'/'âˆ¾(0âŠ¸<â‰ )â—¶".p.bqn"â€¿âŠ‘  (Â»"-p"âŠ¸â‰¡Â¨)âŠ¸/â€¢args
  pâ†©â€¢file.Existsâ—¶{ğ•Š: â€¢Out "Missing .p.bqn file"â‹„âŸ¨âŸ©}â€¿â€¢file.Lines p
  pâ†©{ğ•©/Ëœ0=+`ğ•©='#'}Â¨p                   # remove comments
  pâ†©{(âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)' 'â‰ ğ•©}âŠ¸/Â¨p               # trim whitespace
  pâ†©p/Ëœ(0<â‰ )Â¨p                         # remove empty lines
  pâ†©{ğ•©âŠ”Ëœâ—‹((Â¬':'=ğ•©)âŠ¸/)+Â´(âŒˆ`=âŸœğ•©)Â¨": "}Â¨p # parse into groups file:line query (TODO parse : not in {} or ())
  pâ†©â€¢ParseFloatâŠâŠ£Â¨Â¨p
  (1âŠ¸â†“Â¨p)((Â·âŠ‘Â¨âŠâˆ˜âŠ¢âŠ”âŠ¢)pm.SetÂ¨(âŠ¢âŸœâŠâŠ”âŠ£))âŠ‘Â¨p # store queries in pm 

  â€¢Out âˆ¾âŸ¨ansi.magenta,"--",ansi.resetâŸ© # print start of run marker
  (0â‰ â‰ )â—¶("Missing input file"âŠ¸!)â€¿{Runâ€¢wdpathâˆ¾'/'âˆ¾âˆ¾ğ•©} (Â¬âˆ˜(âŠ£âˆ¨Â»)"-p"âŠ¸â‰¡Â¨)âŠ¸/â€¢args 
}
