gl      â†    â€¢Import "./glyphs.bqn"
compile â† gl â€¢Import "./c.bqn"
vm      â†    â€¢Import "./vm.bqn"

ansiâ†{
  eâ‡@+27
  bold_cyanâ‡eâˆ¾"[1;36m"
  resetâ‡eâˆ¾"[0m"
}

pfileâ†".p.bqn"

lfâ†@+10

fmapâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
imapâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© #cached imported files
pmapâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© #cached queries match to filenames

Infoâ†{ 
  kâ†pmap.Keys @

  zâ†ğ•©/ËœÂ¬".bqn"âŠ¸â‰¡Â¨Â¯4â†‘Â¨ğ•© 
  kâ†©k/Ëœâˆ¨Â´Â¨â·âŸœzÂ¨k # take first matching files

  ("Missing file " âˆ¾ ğ•©) ! â€¢file.Exists ğ•©

  file  â‡ ğ•©
  query â‡ (0âŠ¸â‰ â‰ )â—¶âŸ¨âŸ©â€¿(pmap.Getâˆ˜âŠ‘) k
  src   â‡ â€¢file.Chars file
  lines â‡ (lfâŠ¸â‰ )âŠ¸/Â¨srcâŠ”ËœÂ»+`lf=src
  ln    â‡ +`src=lf  
  col   â‡ âˆ¾(â†•â‰ )Â¨âŠ”Ëœ+`src=@+10
}

ctx â‡ {
  s â‡ âŸ¨âŸ©
  Push â‡ { ğ•Š ğ•©:
    fâ†ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿(â€¢ns.GetâŸœ"cwd") Peek @
    {ğ•© fmap.Set Info f}âŸ(Â¬âˆ˜fmap.Has) f
    sâˆ¾â†©< { cwdâ‡â€¢file.Parent f }
    fmap.Get f
  }

  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                 # Return but don't pop top value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s}             # Pop ğ•© values; return as list
}

# Debug stack: keep track of calls
dbg â† {
  s â† âŸ¨âŸ©                          # Stack (a list)
  Push  â‡ {sâˆ¾â†©<ğ•© } # p: start/end position of call
  Pop   â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Print â‡ { ğ•Š: 
    â€¢Out "Error: " âˆ¾ â€¢CurrentError@
    {ğ•Š offâ€¿colâ€¿lnâ€¿file : 
      infoâ†fmap.Get file
      â€¢Out âˆ¾âŸ¨ansi.bold_cyan, file/ËœÂ¬(1Â¨â†•1-Ëœâ‰ p)âˆ¾(pâ†â€¢wdpathâˆ¾'/')â·file,':',â€¢Fmt ln, ansi.resetâŸ©
      â€¢Out âˆ¾âŸ¨"  ",(ln-1)âŠ‘info.linesâŸ©
      â€¢Out âˆ¾âŸ¨"  ",(' 'Â¨â†•col), 'âˆ§'Â¨â†•off+1âŸ©
    }Â¨âŒ½s
  }
}

fileâ‡{
  Linesâ‡{ 
    ğ•© : "/"â‰¤â—‹â‰ â—¶0â€¿(âŠ£â‰¡â‰ âŠ¸â†‘)ğ•© ? â€¢file.Lines ğ•© 
  ; ğ•© : âŸ¨cwdâŸ©â†ctx.Peek @ â‹„ â€¢file.Lines cwdâˆ¾ğ•© 
  } 
  List â‡{ âŸ¨cwdâŸ©â†ctx.Peek @ â‹„ â€¢file.List  cwdâˆ¾ğ•© } 
}

syslistâ†âŸ¨
    "p"â€¿â€¢Show # TODO show file and line number
    "while"â€¿â€¢_while_
    "hash"â€¿â€¢Hash
    "parsefloat"â€¿â€¢ParseFloat
    "ffi"â€¿â€¢FFI
    "out"â€¿â€¢Out
    "exit"â€¿â€¢Exit
    "file"â€¿file
    "flines"â€¿file.Lines
    "math"â€¿â€¢math
    "ns"  â€¿â€¢ns
    "show"â€¿â€¢Show
    "bqn"â€¿â€¢Bqn
    "repr"â€¿â€¢Repr
    "type"â€¿â€¢Type
âŸ©

System â†{ ğ•Š args:
  FindSys â† {
    i â† ğ•¨âŠğ•©
    { ! âˆ¾âŸ¨"Unknown system value",(1â‰ â‰ ğ•©)/"s",":"âŸ©âˆ¾" â€¢"âŠ¸âˆ¾Â¨ğ•© }âˆ˜/âŸœğ•©âŸ(âˆ¨Â´) i=â‰ ğ•¨
    i
  }

  { ğ•¨âŠ¸FindSysâŠğ•©Ë™ }Â´âˆ¾<Ë˜â‹ˆË˜â‰>syslistâˆ¾âŸ¨ "import"â€¿Import, "args"â€¿ğ•© âŸ©
}

CmpCatchâ†{ info ğ•Š src:
  âŸ¨loc,msgâŸ©â†â€¢CurrentError@
  sâ€¿eâ†locâ†©â¥Šloc # convert to âŸ¨s,eâŸ©
  mâ†âˆ¨Â´info.lnâŠ¸=Â¨locâŠinfo.ln # 
  â€¢Out "Error: "âˆ¾msg
  â€¢Out info.fileâˆ¾":"âˆ¾ â€¢Fmt sâŠ‘info.ln
  â€¢Out (sâŠ‘info.ln)âŠ‘info.lines
  â€¢Out âŠ£â—¶" âˆ§"Â¨Â«(m/â†•â‰ src)âˆŠ(s+â†•1+e-s)
  â€¢Exit 1
}

Runâ‡Import â‡ {
    ğ•Š ğ•© : âŸ¨âŸ© ğ•Š ğ•©
; Â· ğ•Š ğ•© : imap.Has ğ•© ? imap.Get ğ•©
; args ğ•Š ğ•© : 
    infoâ†ctx.Push ğ•©

    c â† (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System args, âŸ¨âŸ©âŸ©âŠ¸Compile)âŠ(infoâŠ¸CmpCatch) info.src
    r â† {infoâ‡infoâ‹„dbgâ‡dbg} VM c

    ğ•© imap.Set r
    ctx.Pop 1 
    r
}

BQNâ†{
  kâ†ğ•¨.Keys@ â‹„ vâ†ğ•¨.Values@
  evalâ†â€¢ReBQN {systemâ‡âŸ¨"show"â€¿â€¢Show, "p"â€¿â€¢Show, "args"â€¿vâŸ©}
  Eval âˆ¾âŸ¨"âŸ¨",1â†“âˆ¾','âŠ¸âˆ¾Â¨k,"âŸ©â† â€¢args",lf,ğ•©âŸ©
}

MakeQueryâ‡{ fâ€¿bâ€¿c ğ•Š pâ€¿src:
  nâ†0

  Condâ†{ 
    câ‰¡1 ? 1 ;
      nâ†n+1
      1â‰¡ğ•© Bqn c # TODO line number
  }

  Runâ‡{ 
    h ğ•Š cmpâ€¿ln: (bâ‰¡ln)â—¶0â€¿Cond h ? 
      kâ†h.Keys@ â‹„ vâ†h.Values@
      â€¢Out ansi.bold_cyanâˆ¾pâˆ¾ansi.reset
      â€¢Show h Bqn src
  ; @
  } 
}

PBQNFileâ†{ 
  ğ•Š ğ•© : â€¢file.Exists ğ•© ? 
    pâ†â€¢file.Lines ğ•©
    pâ†©{ğ•©/Ëœ0=+`ğ•©='#'}Â¨p        # remove comments
    pâ†©{(âˆ¨`âˆ§âˆ¨`âŒ¾âŒ½)' 'â‰ ğ•©}âŠ¸/Â¨p    # remove empty lines
    pâ†©p/Ëœ(0<â‰ )Â¨p
    mâ†{1â‰¤+`ğ•©=' '}Â¨p
    lâ†â€¢ParseFloatâŠâŠ£Â¨Â¨":"âŠ¸((âŠ¢-ËœÂ¬Ã—Â·+`1âŠ¸Â»âŠ¸<)âˆ˜âˆŠËœâŠ”âŠ¢)Â¨(Â¬m)/Â¨p
    fâ†âŠ‘Â¨lâ†©(3â†‘âˆ¾âŸœ1)Â¨l # enforce default conditional value
    qâ†l MakeQueryÂ¨pâ‹ˆÂ¨m/Â¨p
    (âŠ‘Â¨âŠâŠ¸âŠ”f) pmap.SetÂ¨qâŠ”ËœâŠf # store queries matched to filenames
; ğ•Š ğ•© : â€¢Out "Missing pbqn file " âˆ¾ ğ•©
}

usageâ†âˆ¾âˆ¾âŸœlfÂ¨âŸ¨
  "Usage: pbqn [options] [file.bqn [arguments]]"
  "Options:"
  "  -p file   query file"
âŸ©

# === Main ===
{
  {ğ•Š: â€¢Out usage â‹„ â€¢Exit 0}âŸ(0âŠ¸=) â‰ â€¢args 
  fâ†(Â¬âˆ˜(âŠ£âˆ¨Â»)"-p"âŠ¸â‰¡Â¨)âŠ¸/â€¢args â‹„ "Missing input file" ! 0<â‰ f
  pâ†(0âŠ¸<â‰ )â—¶pfileâ€¿âŠ‘  (Â»"-p"âŠ¸â‰¡Â¨)âŠ¸/â€¢args
  PBQNFile â€¢wdpathâˆ¾'/'âˆ¾p
  â€¢Out "--PBQN--"
  Run â€¢wdpathâˆ¾"/"âˆ¾âŠ‘f
}
